#!/usr/bin/env node

/**
 * PRPROMPTS CLI Wrapper
 * Unified interface for Claude Code, Qwen Code, and Gemini CLI
 * Version: 4.1.0
 * Enhanced with API validation, rate limiting, interactive mode, progress indicators, and command history
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const os = require('os');

// Configuration
const VERSION = '4.1.0';
const CONFIG_DIR = path.join(os.homedir(), '.prprompts');
const CONFIG_FILE = path.join(CONFIG_DIR, 'config.json');

// Colors
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

// Helper: Colored output
function colorize(text, color) {
  return `${colors[color] || ''}${text}${colors.reset}`;
}

// Helper: Check if command exists
function commandExists(cmd) {
  try {
    execSync(`command -v ${cmd}`, { stdio: 'ignore' });
    return true;
  } catch {
    return false;
  }
}

// Load configuration with environment variable support
function loadConfig() {
  // Start with defaults
  let config = {
    version: VERSION,
    default_ai: process.env.PRPROMPTS_DEFAULT_AI || 'claude',
    ais: {
      claude: { enabled: commandExists('claude') },
      qwen: { enabled: commandExists('qwen') },
      gemini: { enabled: commandExists('gemini') }
    },
    features: {
      auto_update: process.env.PRPROMPTS_AUTO_UPDATE !== 'false',
      verbose: process.env.PRPROMPTS_VERBOSE !== 'false',
      telemetry: process.env.PRPROMPTS_TELEMETRY === 'true'
    }
  };

  // Load from file if exists
  if (fs.existsSync(CONFIG_FILE)) {
    try {
      const fileConfig = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));

      // Merge file config with defaults, env vars take precedence
      config = {
        ...fileConfig,
        version: VERSION,
        default_ai: process.env.PRPROMPTS_DEFAULT_AI || fileConfig.default_ai || config.default_ai,
        features: {
          ...fileConfig.features,
          auto_update: process.env.PRPROMPTS_AUTO_UPDATE !== undefined ?
            process.env.PRPROMPTS_AUTO_UPDATE !== 'false' :
            fileConfig.features?.auto_update,
          verbose: process.env.PRPROMPTS_VERBOSE !== undefined ?
            process.env.PRPROMPTS_VERBOSE !== 'false' :
            fileConfig.features?.verbose,
          telemetry: process.env.PRPROMPTS_TELEMETRY !== undefined ?
            process.env.PRPROMPTS_TELEMETRY === 'true' :
            fileConfig.features?.telemetry
        }
      };
    } catch (error) {
      console.error(colorize('Error loading config:', 'red'), error.message);
      // Return defaults on error instead of exiting
      return config;
    }
  }

  // Apply timeout and retry settings from env
  if (process.env.PRPROMPTS_TIMEOUT) {
    config.timeout = parseInt(process.env.PRPROMPTS_TIMEOUT, 10);
  }
  if (process.env.PRPROMPTS_RETRY_COUNT) {
    config.retryCount = parseInt(process.env.PRPROMPTS_RETRY_COUNT, 10);
  }

  return config;
}

// Validate configuration
function validateConfig(config) {
  const errors = [];
  const warnings = [];

  // Check version format
  if (!config.version || !/^\d+\.\d+\.\d+/.test(config.version)) {
    warnings.push('Invalid version format in config');
  }

  // Check default AI is valid
  const validAIs = ['claude', 'qwen', 'gemini'];
  if (config.default_ai && !validAIs.includes(config.default_ai)) {
    errors.push(`Invalid default_ai: ${config.default_ai}. Must be one of: ${validAIs.join(', ')}`);
  }

  // Check that at least one AI is enabled
  const enabledAIs = Object.entries(config.ais || {})
    .filter(([_, ai]) => ai.enabled)
    .map(([name]) => name);

  if (enabledAIs.length === 0) {
    errors.push('No AI assistants are enabled. Please install at least one.');
  }

  // Check that default AI is enabled
  if (config.default_ai && config.ais[config.default_ai] && !config.ais[config.default_ai].enabled) {
    warnings.push(`Default AI '${config.default_ai}' is not enabled. Will use first available AI.`);
  }

  // Validate timeout and retry settings
  if (config.timeout && (config.timeout < 1000 || config.timeout > 600000)) {
    warnings.push('Timeout should be between 1000ms and 600000ms (10 minutes)');
  }

  if (config.retryCount && (config.retryCount < 1 || config.retryCount > 10)) {
    warnings.push('Retry count should be between 1 and 10');
  }

  // Check features
  if (config.features) {
    const validFeatures = ['auto_update', 'verbose', 'telemetry'];
    const unknownFeatures = Object.keys(config.features).filter(f => !validFeatures.includes(f));
    if (unknownFeatures.length > 0) {
      warnings.push(`Unknown features in config: ${unknownFeatures.join(', ')}`);
    }
  }

  return { errors, warnings, isValid: errors.length === 0 };
}

// Save configuration
function saveConfig(config) {
  try {
    // Validate before saving
    const validation = validateConfig(config);
    if (!validation.isValid) {
      console.error(colorize('âœ— Configuration errors:', 'red'));
      validation.errors.forEach(e => console.error(`  - ${e}`));
      return false;
    }

    fs.mkdirSync(CONFIG_DIR, { recursive: true });
    fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));
    return true;
  } catch (error) {
    console.error(colorize('Error saving config:', 'red'), error.message);
    return false;
  }
}

// Get best available AI
function getBestAI(config) {
  const available = Object.entries(config.ais)
    .filter(([_, ai]) => ai.enabled)
    .map(([name]) => name);

  if (available.length === 0) {
    console.error(colorize('âœ— No AI assistants found!', 'red'));
    console.error(colorize('\nInstall at least one:', 'yellow'));
    console.error('  npm install -g @anthropic-ai/claude-code');
    console.error('  npm install -g @google/gemini-cli');
    console.error('\nOr run: prprompts install');
    process.exit(1);
  }

  // Return default if available, otherwise first available
  if (available.includes(config.default_ai)) {
    return config.default_ai;
  }
  return available[0];
}

// Execute AI command with retry logic and better error handling
function execAI(ai, args, config = null) {
  const command = `${ai} ${args.join(' ')}`;
  const cfg = config || loadConfig();
  const timeout = cfg.timeout || 120000; // 2 minutes default timeout
  const retries = cfg.retryCount || 3;

  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      if (attempt > 1) {
        console.log(colorize(`\nRetry attempt ${attempt}/${retries}...`, 'yellow'));
      }

      execSync(command, {
        stdio: 'inherit',
        timeout: timeout,
        windowsHide: true
      });
      return; // Success - exit function
    } catch (error) {
      const isLastAttempt = attempt === retries;

      // Handle specific error cases
      if (error.code === 'ENOENT') {
        console.error(colorize(`\nâœ— Error: AI command '${ai}' not found`, 'red'));
        console.error(colorize('Please ensure the AI is properly installed:', 'yellow'));
        console.error(`  npm install -g @anthropic-ai/claude-code  (for Claude)`);
        console.error(`  npm install -g @qwenlm/qwen-code         (for Qwen)`);
        console.error(`  npm install -g @google/gemini-cli        (for Gemini)`);
        process.exit(1);
      } else if (error.signal === 'SIGTERM' || error.code === 'ETIMEDOUT') {
        console.error(colorize(`\nâœ— Error: Command timed out after ${timeout/1000} seconds`, 'red'));
        if (!isLastAttempt) {
          console.log(colorize('Retrying...', 'yellow'));
          continue;
        }
      } else if (error.status === 127) {
        console.error(colorize(`\nâœ— Error: Command '${args[0]}' not recognized by ${ai}`, 'red'));
        console.error(colorize('Available commands: create, generate, analyze, etc.', 'yellow'));
        console.error(colorize('Run "prprompts help" for full command list', 'cyan'));
        process.exit(1);
      } else if (error.message && error.message.includes('API')) {
        console.error(colorize(`\nâœ— Error: API key issue detected`, 'red'));
        console.error(colorize('Please check your API key configuration:', 'yellow'));
        console.error(`  ${ai === 'claude' ? 'ANTHROPIC_API_KEY' : ai === 'gemini' ? 'GOOGLE_API_KEY' : 'DASHSCOPE_API_KEY'}`);
        if (!isLastAttempt) {
          continue;
        }
      } else {
        // Generic error
        console.error(colorize(`\nâœ— Error executing ${ai} command`, 'red'));
        if (error.message) {
          console.error(colorize(`Details: ${error.message}`, 'yellow'));
        }
        if (!isLastAttempt) {
          continue;
        }
      }

      if (isLastAttempt) {
        console.error(colorize('\nAll retry attempts failed.', 'red'));
        console.error(colorize('For help, visit: https://github.com/Kandil7/prprompts-flutter-generator/issues', 'cyan'));
        process.exit(error.status || 1);
      }
    }
  }
}

// Import automation modules
const AutomationManager = require('../lib/automation-manager');
const AutomationValidator = require('../lib/automation-validator');

// Import v4.1.0 enhancement modules
const APIKeyValidator = require('../lib/api-key-validator');
const RateLimiter = require('../lib/rate-limiter');
const InteractiveMode = require('../lib/interactive-mode');
const { createProgressBar, createSpinner } = require('../lib/progress-indicator');
const CommandHistory = require('../lib/command-history');

// Import updater module
const Updater = require('../lib/updater');

// Initialize command history
const commandHistory = new CommandHistory();

// Commands

function showHelp() {
  console.log(`
${colorize('PRPROMPTS CLI', 'magenta')} ${colorize(`v${VERSION}`, 'cyan')}
${colorize('Unified interface for Flutter PRPROMPTS generation', 'cyan')}

${colorize('USAGE:', 'bright')}
  prprompts <command> [options]

${colorize('COMMANDS:', 'bright')}
  ${colorize('init', 'green')}              Initialize PRPROMPTS in current project
  ${colorize('create', 'green')}            Create PRD interactively (alias: create-prd)
  ${colorize('auto', 'green')}              Auto-generate PRD from description
  ${colorize('from-files', 'green')}        Generate PRD from existing markdown files
  ${colorize('analyze', 'green')}           Validate and analyze PRD
  ${colorize('generate', 'green')}          Generate all 32 PRPROMPTS (alias: gen)
  ${colorize('gen-phase-1', 'green')}       Generate Phase 1: Core Architecture
  ${colorize('gen-phase-2', 'green')}       Generate Phase 2: Quality & Security
  ${colorize('gen-phase-3', 'green')}       Generate Phase 3: Demo & Learning
  ${colorize('gen-file', 'green')} <name>   Generate single PRPROMPTS file

${colorize('CONFIGURATION:', 'bright')}
  ${colorize('config', 'green')}            Show current configuration
  ${colorize('switch', 'green')} <ai>       Switch default AI (claude|qwen|gemini)
  ${colorize('which', 'green')}             Show which AI will be used
  ${colorize('doctor', 'green')}            Diagnose installation issues

${colorize('AUTOMATION:', 'bright')}
  ${colorize('auto-status', 'green')}       Show automation progress
  ${colorize('auto-validate', 'green')}     Validate code quality & compliance
  ${colorize('auto-bootstrap', 'green')}    Bootstrap project structure
  ${colorize('auto-implement', 'green')} N  Implement N features automatically
  ${colorize('auto-test', 'green')}         Run tests with coverage
  ${colorize('auto-reset', 'green')}        Reset automation state

${colorize('NEW FEATURES (v4.1.0):', 'bright')}
  ${colorize('interactive', 'green')}       Start interactive mode (menu-driven)
  ${colorize('validate-keys', 'green')}     Validate API keys for all AIs
  ${colorize('setup-keys', 'green')}        Interactive API key setup
  ${colorize('rate-status', 'green')}       Check API rate limit status
  ${colorize('history', 'green')}           Browse command history
  ${colorize('history-search', 'green')}    Search command history

${colorize('MAINTENANCE:', 'bright')}
  ${colorize('update', 'green')}            Update PRPROMPTS to latest version
  ${colorize('check-updates', 'green')}     Check if updates are available
  ${colorize('version', 'green')}           Show version information
  ${colorize('help', 'green')}              Show this help message

${colorize('EXAMPLES:', 'bright')}
  ${colorize('prprompts init', 'cyan')}              # Initialize project
  ${colorize('prprompts create', 'cyan')}            # Create PRD interactively
  ${colorize('prprompts generate', 'cyan')}          # Generate all PRPROMPTS
  ${colorize('prprompts switch gemini', 'cyan')}     # Use Gemini CLI
  ${colorize('prprompts doctor', 'cyan')}            # Check installation

${colorize('DOCUMENTATION:', 'bright')}
  https://github.com/Kandil7/prprompts-flutter-generator

${colorize('SUPPORT:', 'bright')}
  https://github.com/Kandil7/prprompts-flutter-generator/issues
`);
}

function showVersion() {
  const config = loadConfig();
  const ai = getBestAI(config);

  console.log(`${colorize('PRPROMPTS CLI', 'magenta')} v${VERSION}`);
  console.log(`${colorize('Default AI:', 'cyan')} ${ai}`);
  console.log('');
  console.log(colorize('Installed AI assistants:', 'cyan'));

  Object.entries(config.ais).forEach(([name, info]) => {
    const status = info.enabled
      ? colorize('âœ“', 'green')
      : colorize('âœ—', 'red');
    console.log(`  ${status} ${name}`);
  });
}

function showConfig() {
  const config = loadConfig();
  console.log(colorize('\nCurrent Configuration:', 'cyan'));
  console.log(JSON.stringify(config, null, 2));
  console.log(colorize(`\nConfig file: ${CONFIG_FILE}`, 'yellow'));
}

function switchAI(newAI) {
  const config = loadConfig();

  if (!['claude', 'qwen', 'gemini'].includes(newAI)) {
    console.error(colorize('âœ— Invalid AI. Choose: claude, qwen, or gemini', 'red'));
    process.exit(1);
  }

  if (!config.ais[newAI]?.enabled) {
    console.error(colorize(`âœ— ${newAI} is not installed`, 'red'));
    console.error(colorize('\nInstall it first:', 'yellow'));
    if (newAI === 'claude') {
      console.error('  npm install -g @anthropic-ai/claude-code');
    } else if (newAI === 'gemini') {
      console.error('  npm install -g @google/gemini-cli');
    } else {
      console.error('  See: https://github.com/QwenLM/qwen-code');
    }
    process.exit(1);
  }

  config.default_ai = newAI;
  saveConfig(config);
  console.log(colorize(`âœ“ Default AI set to: ${newAI}`, 'green'));
}

function showWhich() {
  const config = loadConfig();
  const ai = getBestAI(config);
  console.log(colorize(`Current AI: ${ai}`, 'cyan'));

  // Show command that will be executed
  const testCmd = `${ai} --version`;
  try {
    const version = execSync(testCmd, { encoding: 'utf8' }).trim();
    console.log(colorize(`Version: ${version}`, 'cyan'));
  } catch {
    console.log(colorize('Version: unknown', 'yellow'));
  }
}

function runDoctor() {
  console.log(colorize('\nðŸ” PRPROMPTS Installation Diagnostics\n', 'cyan'));

  // Check Node.js
  console.log(colorize('Node.js:', 'bright'));
  try {
    const nodeVersion = execSync('node --version', { encoding: 'utf8' }).trim();
    console.log(colorize(`  âœ“ ${nodeVersion}`, 'green'));
  } catch {
    console.log(colorize('  âœ— Not found', 'red'));
  }

  // Check npm
  console.log(colorize('npm:', 'bright'));
  try {
    const npmVersion = execSync('npm --version', { encoding: 'utf8' }).trim();
    console.log(colorize(`  âœ“ ${npmVersion}`, 'green'));
  } catch {
    console.log(colorize('  âœ— Not found', 'red'));
  }

  // Check Git
  console.log(colorize('Git:', 'bright'));
  try {
    const gitVersion = execSync('git --version', { encoding: 'utf8' }).trim();
    console.log(colorize(`  âœ“ ${gitVersion}`, 'green'));
  } catch {
    console.log(colorize('  âš  Not found (optional)', 'yellow'));
  }

  // Check AI assistants
  console.log(colorize('\nAI Assistants:', 'bright'));

  ['claude', 'qwen', 'gemini'].forEach(ai => {
    if (commandExists(ai)) {
      try {
        const version = execSync(`${ai} --version`, { encoding: 'utf8' }).trim();
        console.log(colorize(`  âœ“ ${ai}: ${version}`, 'green'));

        // Check config
        const configPath = path.join(os.homedir(), '.config', ai);
        if (fs.existsSync(configPath)) {
          console.log(colorize(`    âœ“ Config: ${configPath}`, 'green'));
        } else {
          console.log(colorize(`    âš  Config not found: ${configPath}`, 'yellow'));
        }
      } catch {
        console.log(colorize(`  âœ“ ${ai}: installed (version unknown)`, 'green'));
      }
    } else {
      console.log(colorize(`  âœ— ${ai}: not installed`, 'red'));
    }
  });

  // Check PRPROMPTS config
  console.log(colorize('\nPRPROMPTS Configuration:', 'bright'));
  if (fs.existsSync(CONFIG_FILE)) {
    console.log(colorize(`  âœ“ Config file: ${CONFIG_FILE}`, 'green'));
    const config = loadConfig();
    console.log(colorize(`  âœ“ Default AI: ${config.default_ai}`, 'green'));
  } else {
    console.log(colorize(`  âš  Config not found: ${CONFIG_FILE}`, 'yellow'));
    console.log(colorize('    Run: prprompts init', 'cyan'));
  }

  console.log('');
}

function initProject() {
  const config = loadConfig();
  const ai = getBestAI(config);

  console.log(colorize('\nðŸš€ Initializing PRPROMPTS project\n', 'cyan'));
  console.log(colorize(`Using AI: ${ai}`, 'cyan'));
  console.log('');

  // Create docs directory
  if (!fs.existsSync('docs')) {
    fs.mkdirSync('docs', { recursive: true });
    console.log(colorize('âœ“ Created docs/ directory', 'green'));
  }

  // Check for project_description.md
  if (!fs.existsSync('project_description.md') && !fs.existsSync('docs/PRD.md')) {
    console.log(colorize('\nðŸ“ No PRD found. Let\'s create one!\n', 'yellow'));
    console.log('Choose a method:');
    console.log('  1) Interactive wizard (10 questions)');
    console.log('  2) Auto-generate from description');
    console.log('  3) Skip for now');
    console.log('');

    // For now, just show instructions
    console.log(colorize('Run one of these commands:', 'cyan'));
    console.log(`  ${ai} create-prd       # Interactive wizard`);
    console.log(`  ${ai} auto-gen-prd     # Auto-generate`);
  } else {
    console.log(colorize('âœ“ PRD found', 'green'));
  }

  console.log('');
  console.log(colorize('Next steps:', 'cyan'));
  console.log(`  1. prprompts create    # Create PRD`);
  console.log(`  2. prprompts generate  # Generate PRPROMPTS`);
  console.log('');
}

// Main command router
function main() {
  const args = process.argv.slice(2);
  const command = args[0];

  // Validate config on startup (unless showing help/version)
  if (command && command !== 'help' && command !== '--help' && command !== '-h' &&
      command !== 'version' && command !== '--version' && command !== '-v') {
    const config = loadConfig();
    const validation = validateConfig(config);

    // Show warnings if any
    if (validation.warnings.length > 0 && config.features?.verbose !== false) {
      console.log(colorize('âš  Configuration warnings:', 'yellow'));
      validation.warnings.forEach(w => console.log(colorize(`  - ${w}`, 'yellow')));
      console.log('');
    }

    // Exit on errors
    if (!validation.isValid) {
      console.error(colorize('âœ— Configuration errors:', 'red'));
      validation.errors.forEach(e => console.error(colorize(`  - ${e}`, 'red')));
      console.error('');
      console.error(colorize('Run "prprompts doctor" to diagnose issues', 'cyan'));
      process.exit(1);
    }

    // Background update check (non-blocking, if auto-update enabled)
    if (config.features?.auto_update !== false && Updater.shouldNotifyUpdate()) {
      // Run background check asynchronously
      Updater.backgroundUpdateCheck().then(updateInfo => {
        // Check if update notification should be shown
        const notification = Updater.getUpdateNotification();
        if (notification) {
          Updater.displayUpdateNotification(notification);
        }
      }).catch(() => {
        // Silently ignore update check errors
      });
    }
  }

  // Handle help/version/no command
  if (!command || command === 'help' || command === '--help' || command === '-h') {
    showHelp();
    return;
  }

  if (command === 'version' || command === '--version' || command === '-v') {
    showVersion();
    return;
  }

  // Handle special commands
  switch (command) {
    case 'config':
      showConfig();
      return;

    case 'switch':
      switchAI(args[1]);
      return;

    case 'which':
      showWhich();
      return;

    case 'doctor':
      runDoctor();
      return;

    case 'init':
      initProject();
      return;

    case 'update':
      Updater.performUpdate().then(() => {
        process.exit(0);
      }).catch(error => {
        console.error(colorize('Update failed:', 'red'), error.message);
        process.exit(1);
      });
      return;

    case 'check-updates':
      Updater.checkForUpdates(false).then(updateInfo => {
        if (updateInfo.error) {
          console.error(colorize('Error checking for updates:', 'red'), updateInfo.error);
          process.exit(1);
        }
        process.exit(0);
      });
      return;

    // Automation commands
    case 'auto-status':
      const statusManager = new AutomationManager();
      statusManager.generateReport();
      return;

    case 'auto-validate':
      const validator = new AutomationValidator();
      validator.validate().then(results => {
        validator.generateReport();
        process.exit(results.passed ? 0 : 1);
      });
      return;

    case 'auto-bootstrap':
      const bootstrapManager = new AutomationManager();
      bootstrapManager.startBootstrap().then(result => {
        if (result.success) {
          console.log(colorize('âœ… Bootstrap complete!', 'green'));
        } else {
          console.log(colorize('âŒ Bootstrap failed:', 'red'), result.errors);
          process.exit(1);
        }
      });
      return;

    case 'auto-implement':
      const count = parseInt(args[1]) || 1;
      const implementManager = new AutomationManager();
      implementManager.executeImplementation(count).then(result => {
        console.log(colorize(`âœ… Implemented ${result.tasksCompleted} tasks`, 'green'));
      });
      return;

    case 'auto-test':
      const testManager = new AutomationManager();
      testManager.runTests().then(() => {
        console.log(colorize('âœ… Tests complete', 'green'));
      });
      return;

    case 'auto-reset':
      const resetManager = new AutomationManager();
      resetManager.reset();
      console.log(colorize('âœ… Automation state reset', 'green'));
      return;

    // New v4.1.0 commands
    case 'interactive':
      const interactive = new InteractiveMode();
      interactive.start().catch(console.error);
      return;

    case 'validate-keys':
      const keyValidator = new APIKeyValidator();
      keyValidator.validateAll().then(results => {
        console.log('\nðŸ“Š API Key Validation Results:\n');
        for (const [ai, result] of Object.entries(results)) {
          if (result.skipped) {
            console.log(`â­ï¸  ${ai}: Skipped (not installed)`);
          } else if (result.valid) {
            console.log(colorize(`âœ… ${ai}: Valid`, 'green'));
          } else {
            console.log(colorize(`âŒ ${ai}: ${result.error}`, 'red'));
          }
        }
      });
      return;

    case 'setup-keys':
      const setupValidator = new APIKeyValidator();
      const setupAI = args[1];
      if (setupAI) {
        setupValidator.setupAPIKey(setupAI).then(() => {
          console.log('Setup complete');
        });
      } else {
        console.log('Please specify an AI: setup-keys claude|qwen|gemini');
      }
      return;

    case 'rate-status':
      const rateLimiter = new RateLimiter();
      rateLimiter.displayUsage();
      return;

    case 'history':
      commandHistory.browseHistory().then(() => {
        process.exit(0);
      });
      return;

    case 'history-search':
      const searchQuery = args.slice(1).join(' ');
      const searchResults = commandHistory.searchHistory(searchQuery);
      console.log(`\nðŸ” Search results for "${searchQuery}":\n`);
      searchResults.slice(0, 20).forEach(cmd => {
        console.log(`  ${cmd}`);
      });
      return;
  }

  // Load config and get AI
  const config = loadConfig();
  const ai = getBestAI(config);

  // Track command in history
  const fullCommand = `prprompts ${process.argv.slice(2).join(' ')}`;
  commandHistory.addCommand(fullCommand, { project: path.basename(process.cwd()) });

  // Map user-friendly commands to AI commands
  const commandMap = {
    'create': 'create-prd',
    'auto': 'auto-gen-prd',
    'from-files': 'prd-from-files',
    'analyze': 'analyze-prd',
    'generate': 'gen-prprompts',
    'gen': 'gen-prprompts',
    'gen-phase-1': 'gen-phase-1',
    'gen-phase-2': 'gen-phase-2',
    'gen-phase-3': 'gen-phase-3',
    'gen-file': 'gen-file'
  };

  const aiCommand = commandMap[command] || command;
  const aiArgs = [aiCommand, ...args.slice(1)];

  if (config.features?.verbose) {
    console.log(colorize(`â†’ Using ${ai}`, 'cyan'));
  }

  execAI(ai, aiArgs, config);
}

// Run
main();
